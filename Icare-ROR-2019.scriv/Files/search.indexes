<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="2C48F37C-16CD-4DCA-84F1-6254FAF3D9E0">
            <Title>resources :model</Title>
            <Text>Mettre resources :&lt;model&gt; dans le fichier `routes.rb` revient à créer automatiquement les méthodes et variables suivantes :

Si &lt;model&gt; = users

HTTP request
URL
Action (méthode)
Route nommée
But
GET
/users
index
users_path
Liste des users
POST
/users
create
users_path
Création d'un user
GET
/users/:id
show
user_path(id)
Fiche de l'user
PATCH
/users/:id
update
user_path(id)
Modification de l'user
DELETE
/users/:id
destroy
user_path(id)
Destruction d'un user
GET
/users/new
new
new_user_path
Fiche d'inscription
GET
/users/:id/edit
edit
edit_user_path(:id)
Page d'édition de l'user

</Text>
        </Document>
        <Document ID="4ECD23B3-5580-4099-8B3F-57FB1359B9F1">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="4CAA24B0-8647-4719-8E05-5068C833BD04">
            <Title>Download</Title>
            <Text>Il existe deux moyens principaux pour télécharger un document :

	•	un lien qui conduit directement au téléchargement
	•	une redirection contenant l'url du document.

PAR UN LIEN

Deux méthodes permettent de générer le lien (à écrire dans la page), pour télécharger le document :

Utiliser la méthode `url_for` ou `rails_blob_{path|url}` :


	url_for(icdocument.comments)
	# =&gt; Lien de téléchargement du document (à vérifier)
	# Mais je ne sais pas où c'est utilisable, peut-être dans un contrôleur et
	# dans les vues seulement

	rails_blob_path(icdocument.original, disposition: 'attachment')



Pour créer un lien permettant de télécharger le document :


	= link_to doc.filename, rails_blob_path(doc, disposition: 'attachment')


Pour créer un lien à l'extérieur d'un contrôleur ou d'une vue :


	Rails.application.routes.url_helpers.rails_blob_path(
		icdoc.original, 
		only_path: true,
		# 	disposition: 'attachment' # pour un mail ?
	)


PAR REDIRECTION

Pour une redirection, imaginons qu'on est un document `mon.zip` dans le dossier ./public de l'application. Il suffit alors de faire `redirect_to '/mon.zip'` dans un contrôleur pour télécharger le document en restant sur la même page ensuite.


</Text>
        </Document>
        <Document ID="E9462355-BDF3-4C0A-99C8-EC106941D32A">
            <Title>Propriétés directes</Title>
            <Text>J'appelle "propriétés directes" les propriétés qui ne dépendent pas d'autres objets. C'est le cas par exemple de l'adresse email ou du pseudo.

id
Identifiant absolu de l'utilisateur (icarien-ne).
email
Son adresse email, validée
name
Pseudo utilisé sur le site (obligatoire)
nom
Nom réel de l'icarien (obligatoire)
prenom
Prénom réel de l'icarien (obligatoire)
password_digest
Mot de passe encrypté
statut
Bits des privilèges (cf. Statut)
options
Options diverses (cf. Options)
created_at
Date de création de la donnée de l'icarien
updated_at
Date de dernière modification des données de l'user
	
					has_many :watchers
</Text>
        </Document>
        <Document ID="25D5E120-67F9-43EF-B549-2368D4915AF8">
            <Title>Reset</Title>
            <Text>Pour resetter la base :

	$ rails db:reset

Cela détruit les tables et les reconstruit, puis ajoute les graines (seed) définies.</Text>
        </Document>
        <Document ID="A86A6632-0AF1-4B0E-BD81-A5416A907900">
            <Title>Validation</Title>
            <Text>On peut ajouter  allow_nil: true  au  validates  pour dire que la données n'est pas toujours requise pour l'enregistrement, comme c'est le cas avec le mot de passe lors d'une modification du profil.

	validates :password, presence: true, allow_nil: true</Text>
        </Document>
        <Document ID="D855DEAA-8B7B-4D60-8AFD-9C46E9944F12">
            <Title>Helpers HTML</Title>
        </Document>
        <Document ID="89019469-47C4-4FAA-A301-44D718A02881">
            <Title>Production sur Heroku</Title>
            <Text>Si le compte est vérifié (par carte de crédit), on peut utiliser sendgrid pour envoyer des mails en production.

	# On ajoute l'addons
	$ heroku addons:create sendgrid:starter

	# On peut voir les USERNAME et PASSWORD avec :
	$ heroku config:get SENDGRID_USERNAME
	$ heroku config:get SENDGRID_PASSWORD

On ajoute dans le fichier ./config/environments/production.rb


	host = '&lt;nom application&gt;.herokuapp.com'
	config.action_mailer.raise_delivery_errors = true
	config.action_mailer.delivery_method = :smtp
  	config.action_mailer.default_url_options = {host: host}
 	ActionMailer::Base.smtp_settings = {
		address:          'smtp.sendgrid.net',
		port:             587,
		authentication:   :plain,
		user_name:        ENV['SENDGRID_USERNAME'],
		password:         ENV['SENDGRID_PASSWORD'],
		domain:           'heroku.com',
		enable_starttls_auto: true
	}

</Text>
        </Document>
        <Document ID="1559C7B3-6A82-4F52-ACC2-8B1606FDBFE8">
            <Title>Type</Title>
            <Text>
Types de l'étape absolue (propriété :type)

Note : ce sont des bits qui s'additionnent (bit|bit)
Valeurs
Description
0
Aucun type
1
Travail sur la structure
2
Travail sur les personnages
4
Travail sur les thèmes
8
Travail sur les intrigues
16
Travail sur un document en particulier (synopsis, pitch, etc.)
32
Travail de recherche d'idées
64
Travail de réflexion
128
Travail de rédaction
256
Travail d'affinement, de finalisation

</Text>
        </Document>
        <Document ID="29A18D21-012B-40A5-8A5B-5A7D594D6A60">
            <Title>Options</Title>
            <Text>Options pour l'ic-étape.

 Bit
Valeurs possibles
0
1
Bit d'avertissement d'échéance d'étape dépassée
De 0: pas d'avertissement à 9: tous les avertissements ont été donnés, on considère l'icarien comme déserteur.
1
2
Réalité de l'étape
1: l'étape est considérée comme "réelle" (*). 0: l'étape n'est pas réelle.
(*) Une étape « réelle » sera comptabilisée dans les modules à durée déterminée qui doivent suivre 8 étapes en général.
2
3

3
4

4
5

5
6

6
7


</Text>
        </Document>
        <Document ID="29D8F8EB-0FBE-4514-946B-997F1AB597A7">
            <Title>Seed</Title>
            <Text>Pour pouvoir essayer des configurations différentes, on peut utiliser des seeds différents.

Il suffit de les définir dans `./db/seeds/' avec un nom qui commencer par 'seed_'. Par exemple : `seed_inscription.rb'. C'est alors le seed « inscription » et il suffit de jouer la commande ci-dessous pour l'invoquer :


	$ rails db:reset:inscription


Noter que pour charger le seed principal il faut jouer :


	$ rails db:reset:main


</Text>
        </Document>
        <Document ID="25446996-C221-49FD-906A-E06392B051C2">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'un module d'apprentissage d'icarien sont :

belongs_to :ic_module

started_at
La date du début de la pause (ne pas utiliser created_at car la donnée peut être créée plus tard)
ended_at
Date de la fin de la pause
motif
Motif de la pause
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="9090D9B6-DEAF-4775-9196-C6E1B0BEA251">
            <Title>Désignation</Title>
            <Text>La méthode `designation_for(&lt;objet&gt;[, &lt;options&gt;])` permet d'obtenir une désignation humaine de l'objet `&lt;objet&gt;` avec les options `&lt;options&gt;`.

Exemple :


	= designation_for(icdocument, name: true, with_ids: true)

Options

	with_ids: true			Ajoute les ids (administration)
	with_user: true		On ajoute le nom de l'icarien.
	name: true				Utilise le nom (document, étape, module) plutôt que
								l'identifiant.

	full: true		Toutes les options sont activées, sauf celles précédées de "*"</Text>
        </Document>
        <Document ID="8BF94C6F-FBE6-41F2-89D2-F3D02B4208A8">
            <Title>Transmettre le body</Title>
            <Text>Par défaut, les mails utilisent les textes définis dans les vues du dossier ./app/views/&lt;nom_mailer&gt;/

Mais on peut changer ça en définissant la méthode de fabrication du mail ainsi :


	class MonMailerPropre &lt; ApplicationMailer

		def sans_fichier_template(destinataire, corps, sujet)
			mail(to: destinataire.email, subject: sujet) do |fmt|
				fmt.html { render html: corps.safe_html }
			end
		end

	end


On envoie le mail normalement avec :


	lemail = MonMailerPropre.sans_fichier_template(u, "&lt;p&gt;Hello !&lt;/p&gt;", 'Un essai')
	lemail.deliver_now

</Text>
        </Document>
        <Document ID="1CA1269D-400B-42F1-AB79-10F199FDC380">
            <Title>IcEtapes</Title>
            <Text>Les étapes des modules d'icariens</Text>
        </Document>
        <Document ID="1088D74F-8060-4921-A0A8-BCB749FE7D7F">
            <Title>Infos sur la base</Title>
            <Text>Pour obtenir des infos de base sur la base (et notamment le nombre de tables et de rangées), utiliser :


	$ heroku pg:info --app &lt;nom application&gt;

</Text>
        </Document>
        <Document ID="B539AEB0-86C9-4849-8EC0-E8F4F6F2D2A5">
            <Title>Propriétés</Title>
        </Document>
        <Document ID="7559BE7A-0EFB-48FC-8C54-31C94C2BA4AD">
            <Title>Introduction</Title>
            <Text>Ce dossier présente des notes prises au cours de la fabrication de l'application en même temps que la lecture du tutoriel.</Text>
        </Document>
        <Document ID="2C65CED0-60E6-422B-8C55-590CF10161C9">
            <Title>Création</Title>
        </Document>
        <Document ID="04B90E21-621A-4938-A9C0-D1BA3D4D3684">
            <Title>Messages de fin</Title>
            <Text>On définit le message de fin en utilisant l'une de ces deux méthodes :


	success_message 	= '&lt;le message de succès&gt;'
	failure_message 	= '&lt;le message d'échec&gt;'


Pour « aglutiner » plusieurs messages, on utilise les méthodes :


	add_success_message(&lt;message ajouté&gt;) 	# ou add_success_final
	add_failure_message(&lt;problème ajouté&gt;	# ou add_failure_final


Noter qu'il suffit d'utiliser une de ces deux méthodes une seule fois pour que le message de fin soit automatiquement écrit sur la page.</Text>
        </Document>
        <Document ID="AA852350-F90D-44BB-A210-84E06C68A365">
            <Title>Notification</Title>
            <Text>Formulaire type pour une notification qui doit jouer l'action-watcher :

= form_for('&lt;prefix&gt;', url: aw.form_url) do
	= ... champs
	.right.vair
		= submit_tag('Soumettre')</Text>
        </Document>
        <Document ID="78658323-A6C4-4F71-9779-AD1AAA428281">
            <Title>Statuts</Title>
            <Text>
Statuts de l'étape (propriété :status)


Valeurs
Description
0
Jamais affecté
1
Étape démarrée, l'icarien y travaille (valeur par défaut)
2
L'icarien a remis son travail, mais il n'est pas encore reçu
3
Travail téléchargé par Phil
4
Dépôt des commentaires (mais l'icarien ne les a pas téléchargé)
5
L'icarien télécharge ses commentaires
6
Dépôt des documents sur le QDD (donc il faut que l'icarien ait téléchargé ses commentaires)
7
Définition du partage des documents par l'icarien (fin de cycle)

</Text>
        </Document>
        <Document ID="CA019198-A84E-4043-B084-6CFC4864D121">
            <Title>Pauses</Title>
            <Text>Les pauses des modules d'icarien.</Text>
        </Document>
        <Document ID="3C6FEBA9-2B84-4761-B57B-757DC67AC3F0">
            <Title>Dates et temps</Title>
            <Text>Pour formater humainement les dates, utiliser la méthode I18n.localize

Note : il faut le gem `rails-i18n`

On peut définir un format de date particulier dans `./config/locales/fr/general.yml` en définissant :


	fr:
		time:
			formats:
				&lt;nom format&gt;:	'&lt; description avec % &gt;'
				par_exemple:	'le jour %d et le mois %B'


Ensuite, on obtient ce format par :


	hdate = I18n.localize(madate, format: :par_exemple)


Distance entre deux temps


	d = distance_of_time_in_words(temps_debut, temps_fin)
	# Par exemple "moins d'un jour"


Si on est en dehors des views/controllers, il faut ajouter à la classe :


	class MaClasse
		include ActionView::Helpers::DateHelper

		def ma_methode
			...
			d = distance_of_time_in_words(t1, t2)
			...
		end
	end


Pour le détail, voir https://github.com/rails/rails/blob/4cbb9db0a5ff65b0a626a5b043331abefd89e717/actionpack/lib/action_view/helpers/date_helper.rb#L68-103

</Text>
        </Document>
        <Document ID="946B4A4D-AFF2-4C26-AE92-DC92068D6B01">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="09716B8B-3043-4D9D-B067-E8BAACF46E34">
            <Title>Debugger</Title>
            <Text>Le gem `byebug` permet de connaitre l'état de l'application à un moment donné.
Utilisation

Placer `debugger` à l'endroit où l'on veut connaitre l'état de l'application
Lancer l'application (une URL par exemple)
Le serveur s'arrête sur `debugger` et présente une ligne de commande `(byebug)`
Taper les valeurs à connaitre, par exemple `params[controller]` pour connaitre le contrôleur courant.
Taper Ctrl-D pour poursuivre le lancement. </Text>
        </Document>
        <Document ID="85A29CAD-F729-479C-A608-28137D58FA7B">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'un module d'apprentissage absolu sont :

has_many :ic_modules
has_many :users, through :ic_modules

has_many :documents, through: :ic_modules (fonctionne ?)


name
Nom humain du module
P.e. « Structure »
dim
Diminutif, pour les noms par exemple. 
p.e. "Stt" pour "Structure"
module_id
ID du module absolu avant 2016.
tarif
Tarif en euros du module (mensualité pour les modules à durée indéfinie)
nombre_jours
Durée en nombre de jour du module. Si nil, c'est un module à durée indéterminée.
hduree
Durée au format humain, par exemple "deux mois" ou "indéterminée".
short_description
Description courte du module d'apprentissage (HTML)
long_description
Description longue du module (HTML)
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="D02C325F-788D-4867-8BFC-9209A19C2841">
            <Title>De l'association</Title>
            <Text>On crée un action-watcher avec :


	&lt;user&gt;.action_watchers.create(&lt;hash data&gt;)


Hash data doit impérativement comporter :

	:path ou :name ou :action ou :action_watcher_path
		Le chemin d'accès au dossier contenant les éléments du watchers, à partir de
		./lib/action_watchers/
		Par exemple 'user/traitement_candidature'
		Bien sûr, ce path doit renvoyer à un dossier existant.

	:model (String) et :model_id (Integer) ou :objet (instance de class :model)
		L'objet visé par l'action-watcher, par exemple un document.
		Le format privilégié est objet: &lt;instance&gt;
		C'est le nom de classe exacte qui doit être transmis par :model. P.e. « IcModule ».

	:triggered_at ou :at ou :in
		Temps où le watcher devra être déclenché.
		:triggered_at et :at sont des alias
		:in permet de définir dans combien de temps l'action-watcher devra se déclencher. Par 
		exemple, suite au démarrage du module, l'user à 15 jours gratuit. Donc on crée un 
		action-watcher de paiement avec `in: 15.days`.
		</Text>
        </Document>
        <Document ID="FD4D3546-4C14-4455-8D60-EEFE2988D1C1">
            <Title>Introduction</Title>
            <Text>L'administration est gérée par le gem `activeadmin` :

	gem 'activeadmin', '1.3.1'

Pour l'installer pour les utilisateurs, sans utiliser Devise :

	$ rails g active_admin:install --skip-users

Ou avec une classe User existante :

	$ rails g active_admin:install User --skip-users
</Text>
        </Document>
        <Document ID="307E09A9-6774-4120-8FDD-9FA845F959FC">
            <Title>Transformations</Title>
        </Document>
        <Document ID="4E13651D-70C3-4E95-9484-68853AA9B1DA">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="2EEF34E8-AA8F-4467-83F5-71B195456BAC">
            <Title>Menu Select</Title>
            <Text>À partir d'une table :

	&lt;%= select_tag(:&lt;prop&gt;, options_from_collection_for_select(&lt;Table&gt;.all, &lt;clé valeur&gt;, &lt;clé titre&gt;[, &lt;valeur sélectionnée&gt;]) %&gt;

Note : si multiple: true, &lt;valeur sélectionnée&gt; est un Array des valeurs sélectionnées.

Pour définir la taille du menu : size: &lt;taille&gt; (par exemple size: 10 pour montrer 10 valeurs)

Par exemple, pour choisir un utilisateur :

	- users_selected = [2, 12, 34]

	&lt;%= select_tag(:user, options_from_collection_for_select(User.all, :id, :name, users_selected), size: 20, multiple: true %&gt;

</Text>
        </Document>
        <Document ID="00D37C5D-EF94-41AD-BE9B-6DE698823CAE">
            <Title>Formulaires</Title>
            <Text>Pour définir l'action (avec une route en path), il faut utiliser url: ...._path

Par exemple :


	&lt;%= form_form(:ressource, url: ressources_path) do |f| %&gt;
		...
	&lt;% end %&gt;


Ça ne fonctionne pas avec   action: ressources_path .</Text>
        </Document>
        <Document ID="E57050D3-5F5A-405C-A37F-2D3B6D219449">
            <Title>Interruption de l'action-watcher</Title>
            <Text>Dans le programme (méthode `execute`), on peut interrompre la procédure avec la tournure :

	def execute
		...
		interrupt and return
		...
	end


Cela produit l'interruption totale du processus. Les mails `after` ne seront pas envoyés et l'action-watcher ne sera pas détruit. </Text>
        </Document>
        <Document ID="BAFA57AC-76A2-4A28-8350-743C562869C3">
            <Title>Routes</Title>
            <Text>Concernant les routes
Toutes les routes
Pour voir la liste de toutes les routes, jouer en console :


	$ rails routes

_url et _path
On utilise _url pour une URL complète et _path pour une route simple :

about_path 	=&gt; /static_pages/about
about_url		=&gt; www.monsite.org/static_pages/about</Text>
        </Document>
        <Document ID="551C36A2-9C97-44BA-8D23-439EF971C7A7">
            <Title>Mass assignement</Title>
            <Text>Pour éviter les assignements en masse à la création des objets, on peut utiliser (Rails &gt;=4) :

 params.require(:&lt;model&gt;).permit(:prop1, :prop2, ..., :propN) 

Par exemple

def user_params
	params.
		require(:user).
		permit(:name, :email, :password, :password_confirmation)
end

</Text>
        </Document>
        <Document ID="3EDB798B-84FA-4E88-BDA1-9B005E335D27">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="A4CF1F8F-3F7F-4FE5-A9E2-5C1989BD7645">
            <Title>Lien vers le document (download)</Title>
        </Document>
        <Document ID="9F1BE186-BD95-4A3B-8FC9-12D9C4FFF7C0">
            <Title>Cryptage</Title>
            <Text>On utilise la class BCrypt

Soit un mot à coder 'mot en clair'.

	version_claire = 'mot en clair'

	# Pour une utilisation avec un « token », on utilise :
	# C'est ce token qui sera utilisé et comparé à la version
	# enregistrée et cryptée
	version_claire = SessionsHelper.new_token

On peut en obtenir une version cryptée avec :

	version_crypted = BCrypt::Password.create(version_claire[, cost: &lt;prix&gt;])
	# &lt;prix&gt; est un nombre qui augmente le nombre de passe.

On enregistre ce mot crypté dans une table :

	model.update_attribute(cversion: version_crypted.to_s)
	# Remarquer le "to_s"

Pour tester la correspondance :

	c = BCrypt::Password.new(model.cversion)
	# cversion est la version cryptéé et stringifiée du mot de passe
	if c == 'mot en clair' =&gt; true
		# Noter que BCrypt::Password surclasse la méthode '=='
		# C'est OK
	else
		# Le mot codé ne correspond pas
	end</Text>
        </Document>
        <Document ID="8875D1F2-783A-4A58-9A6D-45B9CB0C5E74">
            <Title>Glyphicons</Title>
        </Document>
        <Document ID="A7BE32C8-0E83-4931-9269-DB974BA7BEAA">
            <Title>Utilisation hors contrôleurs/views</Title>
            <Text>Ajouter le code suivant dans la classe où doivent être utilisées les méthodes d'helper :


	def helpers
		ActionController::Base.helpers
	end


</Text>
        </Document>
        <Document ID="BC6E8319-2E4B-44CC-AFB7-F5E9403799F5">
            <Title>Transformations</Title>
            <Text>On peut récupérer le document à l'intérieur de l'application par :


	binary = &lt;owner&gt;.&lt;docref&gt;.download


Par exemple :


	binary = IcDocument.find(12).comments.download
	# mets dans `binary` le code binaire du document commentaires


</Text>
        </Document>
        <Document ID="268196E3-4E44-4A38-AB15-5B6979A7F846">
            <Title>Production (heroku)</Title>
        </Document>
        <Document ID="38C3C0F0-E0FF-4F12-B0D2-D52661303255">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="1AA0E979-C8A9-4E3A-8C8F-3A4909A9AB14">
            <Title>Hash</Title>
            <Text>Pour qu'un élément de hash retourne une valeur définie :

h = Hash.new
h[:inexistant]
=&gt; nil
h = Hash.new('boudin')
h[:inexistant]
=&gt; 'boudin'</Text>
        </Document>
        <Document ID="1697DBCF-E46D-4502-A1B5-3438F7D1B30A">
            <Title>Production (heroku)</Title>
            <Text>S'assurer que tout est bien sur github :


	$ git add -A
	$ git commit -m "Dernier dépôt"
	$ git push


Avant de pusher, s'il peut y avoir du trafic, on se met en maintenance :

	$ heroku maintenance:on 

Pour "pusher" on line, après avoir pushé sur git :

 $ git push heroku # master seulement la première fois

Pour que les migrations soient prises en compte :

Ne pas utiliser :
	$ heroku run rails db:reset
Utiliser :
	$ heroku pg:reset DATA --confirm &lt;nom application heroku&gt; 

	$ heroku run rails db:migrate 

Si on veut peupler la base :

	$	heroku run rails db:seed 

On quitte la maintenance 

	$ heroku maintenance:off 

=== Fin ===

Pour essayer le bac à sable sur heroku :

 $ heroku run rails console --sandbox 
</Text>
        </Document>
        <Document ID="07B24F46-B64D-47F2-B2BD-6A510C8EFA9E">
            <Title>Options</Title>
            <Text>Options pour `original_options` et `comments_options`, les options des deux documents, original et commenté.

 Bit
Valeurs possibles
0
1
Existence
1: Le document existe, 0: le document  n'existe pas
1
2
Partage
0: non défini, 1: partagé, 2: non partagé
2
3
Téléchargement (user ou admin)
0: non chargé, 1: chargé (par l'admin si original, par l'icarien si comments)
3
4
Présence sur le QDD
0: non déposé, 1: déposé sur le QDD (original si original_options, comments si comments_options)
4
5
Définition du partage (obsolète, cf. le 2ème bit)
5
6
Fin du cycle de vie
0: en cours de vie, 1: fin du cycle (avec dépôt sur le QDD et partage)
6
7


</Text>
        </Document>
        <Document ID="EC3EBABA-166D-43B6-828A-5E3098017CAF">
            <Title>Tester une route</Title>
            <Text>Quand on a…
 get 'controller/action' 
… dans le fichier routes, on peut tester ensuite que la page fonctionne par :

test "le contrôleur répond à l'action" do
	get controller_action_url
	assert_response :success
end
</Text>
        </Document>
        <Document ID="0811B557-4572-49A6-8419-67912A32F57B">
            <Title>Générateurs (rails generate)</Title>
            <Text>Infos intéressantes https://api.rubyonrails.org/classes/Rails/Generators/NamedBase.html
</Text>
        </Document>
        <Document ID="5CC616C9-DB87-4C8C-84C9-3CF5CBF94C8D">
            <Title>Mise en place Action Storage</Title>
            <Text>Pour tous les détails, cf. https://guides.rubyonrails.org/active_storage_overview.html

	$ rails active_storage:install

Dans ./config/storage.yml, définir où se fera le stockage.


	local:
		service: Disk
		root: &lt;%= Rails.root.join("storage") %&gt;
 	
	test:
		service: Disk
		root: &lt;%= Rails.root.join("tmp/storage") %&gt;

	# Les lignes suivantes sont ajoutées par moi, sans vérification
	production:
		service: Disk
		root: &lt;%= Rails.root.join("storage") %&gt;


Dans ./config/environments/development.rb et le test certainement :


	# ./config/environments/development.rb
	# ./config/environments/test.rb
	config.active_storage.service = :local


Peut-être faire la même chose en production.</Text>
        </Document>
        <Document ID="AA504757-4CCD-4722-B275-B68347B3B51E">
            <Title>Dates et heures</Title>
            <Text>Pour voir les formats utilisables avec I18n.localize(&lt;date&gt;, format: :&lt;format&gt;), cf. le fichier general.

Possibilité aussi d'utiliser la méthode `human_date_for(&lt;date&gt;, &lt;options&gt;)`
Dans `&lt;options&gt;` on peut définir `:format`. Valeurs principales : `:simple` et `:simple_with_hour`.</Text>
        </Document>
        <Document ID="DE69DD5C-BF52-4BE9-8D6E-71C7F5B139E7">
            <Title>Fonctionnalites</Title>
            <Text>	•	Section des documents de l'icarien(ne)
	•	Section des modules de l'icarien(ne)
	•	Affichage du travail de l'icarien(ne) actif
	•	Le Quai des docs
</Text>
        </Document>
        <Document ID="A7C272CE-1E37-44C1-B2C1-48EFA662F70B">
            <Title>Guard</Title>
            <Text>Le gem Guard permet de lancer automatiquement les tests sur les fichiers modifiés.
Pour le mettre en place dans une application :

# Dans le gemfile
 gem 'guard' 

# Puis jouer (une seule fois) :
 $ bundle exec guard init 
Puis régler le guardfile.

# Pour mettre en route guard (à chaque session) :
 $ bundle exec guard 
À partir de là, toute modification entraînera un test immédiat.</Text>
        </Document>
        <Document ID="334E0A55-0178-43F8-B74F-B8772142669E">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'un document de module d'apprentissage d'icarien sont :

belongs_to :ic_etape
belongs_to :ic_module, through :ic_etape
belongs_to :user, through :ic_etape

has_many :lectures

original_name
Le nom original du fichier tel qu'il a été transmis
affixe
Affixe donné au document
expected_comments_at
Date espérée de remise des commentaires
OBSOLÈTE : c'est l'étape qui porte cette donnée.
commented_at
Date effective de remise des commentaires
note_auteur
La note donnée par l'auteur à son document
original_options
Les options concernant le document original
comments_options
Les options concernant le document commentaire
original_cote
Cote du document original, en fonction des lectures (cf. la table lectures)
comments_cote
Cote du document commentaires, en fonction des lectures.
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="B0D092CD-0E58-4410-A80C-30D09876E418">
            <Title>Git</Title>
            <Text>Au tout départ :


	$ git init


Pour passer sur une autre branche :


	$ git checkout -b &lt;nom-branche&gt;


Pour merger la branche courante :


	$ git checkout master # revenir à la branche maitresse
	$ git merge &lt;nom-branche&gt;


Pour supprimer une branche (après l'avoir mergée) :


	$ git branch -d &lt;nom branche&gt;


Pour voir où on en est :


	$ git status

</Text>
        </Document>
        <Document ID="24E281B2-6523-48F0-A000-2DA9994E85EA">
            <Title>Propriétés</Title>
            <Text>belongs_to :abs_etape
belongs_to :user

question
La question posée à Phil
reponse
Montant du paiement en euros
state
État de la question
0: non répondu, 1: répondu sans indice de satisfaction,
2: le questionneur est satisfait par la réponse, 3: le questionneur n'est pas satisfait par la question
note
Une note (de l'admin) sur cette question, peut-être pour indiquer pourquoi la réponse n'est pas satisfaisante ou pour la compléter.
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="F2B7BD47-50B0-4B31-AC9C-99F70413103D">
            <Title>Reset password</Title>
            <Text>1. L'user clique sur le lien "mot de passe oublié"
2. Il rejoint un formulaire pour donner son adresse mail, et le soumet
3. On lui envoie un ticket avec un lien lui permettant de réinitialiser son mot de passe
4. L'user clique ce lien et…
5. rejoint un formulaire pour entrer une nouveau mot de passe
6. Le nouveau mot de passe (crypté) est enregistré dans la base de donnée et l'user est loggué.</Text>
        </Document>
        <Document ID="6FB5CCF1-9AD5-4EE6-A013-67D740A56E50">
            <Title>TODO</Title>
            <Text>	•	Pouvoir renvoyer le mail de confirmation de l'email (activation_compte, quelque chose comme ça)
	•	Affichage de tous les icarien(ne)s : ne pas afficher a) ceux qui sont supprimés, b) ceux qui n'ont pas encore activé leur compte.
	•	Dans les tâches quotidiennes, supprimer les tickets qui sont périmés
	•	Reprendre tous les textes des modules/étapes pour les passer par `sexize'.
	•	Faire un formulaire me permettant de recharger des documents icariens transmis
	•	Détruire les documents icariens transmis lorsqu'ils ont été déposés sur le quai des docs. Vérifier régulièrement le dossier storage pour que des documents ne restent pas dedans trop longtemps
	•	Voir comment implémenter les outils administration (un seul contrôleur et des méthodes, ou autant de contrôleurs administration — UserAdm — que d'objets (UserAdministration, IcModuleAdmin, PaiementAdmin, etc.)
	•	Depuis le bureau de l'icarien, section Documents, il doit pouvoir re-télécharger tous ses commentaires.
	•	Quand tout sera mis en place, possibilité dans la méthode designation_for d'ajouter l'option :with_path ou :with_url qui liera l'objet à sa page de visualisation.
	•	Gestion des mails d'alerte et de rappel, à mesure que l'échéance est dépassée. Il faudrait un système qui fonctionne pour tout. Est-ce que ça ne serait pas un record `retard`, justement, que chaque élément important pourrait posséder. Par exemple un paiement, une étape (échéance de travail), etc.
	•	Faire l'affichage de l'étape absolue (view abs_etapes/show)
	•	Faire le formulaire de modification de l'étape absolue (view abs_etapes/edit)
</Text>
        </Document>
        <Document ID="0C9EBC50-9996-44DA-A829-4ECE28824855">
            <Title>Possessions</Title>
            <Text>Un user peut posséder :
	•	un seul profil (question : faut-il détacher le profil de l'enregistrement simple ?)
	•	un ou plusieurs icmodules (modules icariens), actifs ou non
	•	des messages frigo
	•	des icetapes (étapes de modules icariens)
	•	des icdocuments (document de travail propres aux modules)
	•	des tickets
	•	des watchers (opération atelier)
	•	des actualités
	•	des témoignages
	•	des questions mini-faq
</Text>
        </Document>
        <Document ID="84DB52AB-2658-48DC-90E4-6164B536CF02">
            <Title>Création du dossier et contenu</Title>
            <Text>Le plus simple est d'utiliser mon générateur rails :


	$ rails g action_watcher &lt;folder&gt;/&lt;nom_du_watcher&gt;[ &lt;options&gt;]


Cela crée tout ce qu'il faut dans le dossier ./lib/action_watchers/&lt;nom_du_watcher&gt;/

Les options peuvent définir les mails à créer dans le dossier. Par défaut, les mails envoyés à la création du watcher ne sont pas copiés. On les ajoute avec :
	--mails-before # pour les créer les deux
	--mail-admin-before
	--mail-user-before
Par défaut, les mails envoyés à l'exécution du watcher sont créés. Pour ne pas les créer, on ajoute les options :
	--no-mails-after # pour les supprimer les deux
	--no-mail-admin-after
	--no-mail-user-after

Par défaut, les deux fichiers notification sont créés, pour l'user et pour l'admin :
	– notify_admin.html.haml
	– notify_user.html.haml
On peut demander à ce que ces fichiers ne soient pas créés avec les options :
	--no-notifies	# Aucune des deux ne sera créé
	--no-notify-admin
	--no-notify-user
Création « à la main »

Faire un dossier dans un des dossiers de ./lib/action_watchers/.

Par exemple le dossier : ./lib/action_watchers/user/contacter/.

Ce dossier doit contenir au minimum le fichier action_watcher.rb avec le code :


	# Dans ./lib/action_watchers/&lt;action_watcher_path&gt;/action_watcher.rb
	class ActionWatcher &lt; ApplicationRecord
		def execute
			... Code à exécuter à l'exécution du watcher ...
		end
	end


Si un mail doit être envoyé à l'administration à la création de cet action-watcher, on le définit dans le dossier de l'action-watcher, dans le fichier :

	.../mailto_admin_before.html.erb

Note : dans tous ces fichiers mails, on doit définir :


	&lt;% self.subject = 'Le sujet du message' %&gt;


Si un mail doit être envoyé à l'user à la création de l'action-watcher, on le définit dans le fichier :

	.../mailto_user_before.html.erb

Dans ces fichiers, on peut utiliser toutes les propriétés de l'action-watcher, à commencer par ` objet `, l'instance visée par le watcher.

On peut aussi utiliser l'helper `action_watcher_helpers.rb` dans le dossier de l'action-watcher pour définir des méthodes propres.

Si des mails doivent être envoyés à l'exécution de l'action-watcher, on les définit dans les fichiers :

	.../mailto_admin_after.html.erb
	.../mailto_user_after.html.erb

Notifications

Il existe deux sortes de notifications : celle qui peuvent accomplir une action (à commencer par jouer l'action-watcher) et celle qui affichent simplement une note informative. Par exemple, quand l'icarien envoie son document de travail, cela génère une action-watcher qui lui crée une notification disant que son document a bien été envoyé et une notification permettant à l'admin (moi, Phil), de télécharger ce document.
Noter qu'à la création de ce watcher, dans cette nouvelle version de l'atelier, un mail d'information est automatiquement envoyé à l'administration tout de suite et un email de confirmation pour l'user.</Text>
        </Document>
        <Document ID="396A70B0-F39F-463A-999B-8B4DFB627037">
            <Title>Options</Title>
            <Text>Propriété : options
C'est un mot de 16 chiffres où chaque chiffre représente une option.


 Bit
Valeurs possibles
0
1
0: à valider, 1: accepté, 2: actif, 3: en pause, 4: inactif, 9: détruit
1
2
Confirmation du mail (1 = confirmé, 0 = non confirmé)
2
3
Redirection après l'identification
cf. la méthode `redirection_after_login` du fichier sessions_helper
3
4

4
5

5
6

6
7


</Text>
        </Document>
        <Document ID="7E5FC383-7CAE-4AA6-B3AE-851220B7CB10">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'un module d'apprentissage d'icarien sont :

belongs_to :ic_module
belongs_to :user, through :ic_module

objet
Objet du paiement
montant
Montant du paiement en euros
facture
Le texte de la facture complète (HTML)
note
Une note (de l'admin) sur ce paiement
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="3C7DE251-2F53-4E77-A75A-CBF210890BCC">
            <Title>State</Title>
            <Text>
Statut (état) du module (propriété :state)


Valeurs
Description
0
Module en attente de démarrage
1
Module d'apprentissage en cours de travail
2
Module d'apprentissage en pause
3
Module terminé normalement
4
Module interrompu/abandonné
5

6

7


</Text>
        </Document>
        <Document ID="58768660-DA20-42FD-B4DF-FB51595A3C15">
            <Title>Modules</Title>
            <Text>Voir : 

https://www.jeuweb.org/showthread.php?tid=5965</Text>
        </Document>
        <Document ID="0CF03159-616A-4D64-8DC9-9482E2E35B00">
            <Title>Prévisualisation</Title>
            <Text>Pour prévisualiser un mail envoyé en développement (mais pas par la console, je crois, et peut-être seulement généré par test), utiliser l'url :

	http://localhost:3000/rails/mailer/&lt;nom_du_mailer&gt;/&lt;nom_du_fichier_template&gt; 

Par exemple, si on a un mailer `UserMailer` et qu'on envoie un message `mon_message` (qui est donc une méthode de UserMailer et l'affixe du fichier template contenant le code), on pourra le visualiser à l'adresse :

	http://localhost:3000/rails/mailer/user_mailer/mon_message 

</Text>
        </Document>
        <Document ID="76F67813-0941-4603-A1D3-54C572B2F64F">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="43597D1A-4853-408C-A109-903346FF9956">
            <Title>Glyphicons</Title>
            <Text>Voir tous les glyphicons utilisables avec bootstrap

https://getbootstrap.com/docs/3.3/components/

Pour en insérer un :

	%span.glyphicon.glyphicon-&lt;nom&gt;{'aria-hidden' =&gt; 'true'}

On peut les mettre dans la couleur qu'on veut ('color: ...')
La taille se règle en fonction du conteneur, mais on peut utiliser aussi des `btn-&lt;taille&gt;' pour la régler, comme `btn-sm', `btn-lg', etc.
Ajouter un `aria-label' si c'est un bouton , pour l'accessibilité.</Text>
        </Document>
        <Document ID="F4920AD3-E838-49ED-AE17-6C88E0C4A799">
            <Title>Production (heroku)</Title>
        </Document>
        <Document ID="DF310288-799D-45D4-80B4-79459E833115">
            <Title>Options</Title>
            <Text>Options pour l'ic-module.

OBSOLÈTE — Mais il faut passer les valeurs du bit 0 dans la propriété :state.

 Bit
Valeurs possibles
0
1
cf. state
1
2

2
3

3
4

4
5

5
6

6
7


</Text>
        </Document>
        <Document ID="8A7EADC0-235B-46CA-B142-90FAEE6A846C">
            <Title>content_tag</Title>
            <Text>content_tag(:&lt;balise&gt;, &lt;contenu&gt;, {&lt;options&gt;})

Par exemple :

         		    
	content_tag(:div, "Bienvenue !", class: "notice-message")


… produit :


	&lt;div class="notice-message"&gt;
		Bienvenue !
	&lt;/div&gt;

</Text>
        </Document>
        <Document ID="484A8C6E-2AD2-4AD3-A9A4-990B4614986A">
            <Title>Statut</Title>
        </Document>
        <Document ID="FD490A50-CD60-460B-8A8F-02FB90543C80">
            <Title>Mails</Title>
            <Text>Pour générer un nouveau "mailer"


	$ rails generate mailer &lt;NomMailer&gt; &lt;methode-mail&gt; \
						                  &lt;methode-mail&gt; ... 

</Text>
        </Document>
        <Document ID="19E59F12-6DD0-4D7C-A210-D717164470F3">
            <Title>Essayer une URL</Title>
            <Text>Pour essayer une url, on peut ajouter le paramètre `urltry` à l'url. Cela ajoute un "essayer l'URL : ...." dans l'entête.</Text>
        </Document>
        <Document ID="4B837D6C-FF1A-44AF-B30E-05A9264C532B">
            <Title>Ajouter ressource</Title>
            <Text>

	$ rails generate active_admin:resource &lt;NomRessource&gt;

Noter que le nom de la ressource est au singulier (nom de la classe).</Text>
        </Document>
        <Document ID="7374CC1D-A149-4586-B0B7-5E5EBA139D83">
            <Title>Quotidien programmation</Title>
            <Text>Opérations de dépôt
 $ git add -A  # pour ajouter les nouveaux fichiers
 $ git commit -am "Message dépôt"  # pour faire un nouveau dépôt
 $ git push  # pour déposer ce dépôt
 $ git push heroku master  # pour actualiser ce dépôt sur heroku
Ajout d'un nouveau gem
Quand on ajoute un nouveau gem, il faut :

 $ bundler install --without production 

(note : le `--without production' n'est utile qu'une fois)

Puis exécuter les opérations de dépôt ci-dessus.</Text>
        </Document>
        <Document ID="49A5533E-DE18-4CFC-A77D-5C2A3324D69F">
            <Title>Redirection</Title>
            <Text>Pour suivre une redirection dans un test, il faut utiliser la ligne :

 follow_redirect! 

Je le fais par exemple après une inscription OK, lorsqu'on redirige l'utilisateur vers une page de confirmation complète.</Text>
        </Document>
        <Document ID="B263E8D4-8EB7-4ACF-A69C-D34E2C6C4D99">
            <Title>Récupérer une variable</Title>
            <Text>Il faut que ce soit une variable d'instance (@...)

	v = assigns(:variable)</Text>
        </Document>
        <Document ID="B5ABE287-7122-48A9-9B89-9C1687BE9664">
            <Title>Autres ressources</Title>
            <Text>Le "Rails style guide"

https://github.com/rubocop-hq/rails-style-guide</Text>
        </Document>
        <Document ID="35F85038-E2A3-4A94-9893-EA03D4942E12">
            <Title>render</Title>
            <Text>
	&lt;% @users.each do |user| %&gt;
		&lt;li&gt;
			&lt;%= user.name %&gt;
		&lt;/li&gt;
	&lt;% end %&gt;


On peut créer un partiel `_user.html.erb' et appeler :


	&lt;% @users.each do |user| %&gt;
		&lt;%= render 'user' %&gt;
	&lt;% end %&gt;


Ou simplement :


	&lt;% @users.each do |user| %&gt;
		&lt;%= render user %&gt;
	&lt;% end %&gt;


Et même :


	&lt;%= render @users %&gt;      


Explication :
Ce "render" recevant une collection d'objets de type User, il cherche un partiel de nom '_user.html.erb' pour traiter chaque élément de la collection.</Text>
        </Document>
        <Document ID="937AD4E4-2058-41C8-9507-80163F973587">
            <Title>Notes</Title>
            <Text>Peut-être mettre les dossiers des actions-watchers dans lib/ et utiliser `require_dependency` pour les utiliser. En fait, il semble que 'require_dependency' recharge vraiment, même la seconde fois.
Pour pouvoir utiliser require_dependency, il faut ajouter dans le fichier config/application.rb :


	config.watchable_dirs['lib'] = [:rb]


Note : en fait, j'ai utilisé simplement `load` et ça fonctionne.</Text>
        </Document>
        <Document ID="3C7F480B-142F-454E-AC8A-BC1FD34ABBB2">
            <Title>ActionWatchers</Title>
            <Text>Watchers
Réflexion
Adopte-t-on le même fonctionnement que sur l'ancien site ? C'est-à-dire que les actions sont déclenchées par des notifications complexes.
À quoi est-ce que ça ressemblerait dans une application Rails ?

Il y aurait un model ActionWatcher qui serait en même temps un observateur et une action possible. Il surveille d'un côté et opère de l'autre.
Est-ce qu'il faudrait des AbsActionWatcher qui correspondraient aux choses à faire ? Par exemple, quand l'icarien doit procéder à un paiement, c'est toujours la même action : au moment venu, on lui présente un bouton pour qu'il rejoigne un formulaire de paiement. Quand il a payé, un mail lui est envoyé, confirmant le paiement et un mail est envoyé à l'administration informant du paiement.
Avant, ces choses se trouvaient dans des fichiers (les mails à envoyer, les formulaires utiles). Maintenant, on pourrait les mettre dans une base de donnée du modèle AbsActionWatcher. Mais j'aimerais mieux conserver les dossiers. 

Il y aurait donc aussi le controller ActionWatchers qui répondrait aux différentes méthodes, comme dans le truc original.
La méthode `run` exécuterait le watcher, c'est-à-dire le code contenu dans 'action_watcher.rb' du dossier et définissant la méthode ActionWatcher.run.
La méthode `action_admin` retournerait le code du formulaire 'action_admin.html.erb' s'il existe et que c'est l'admin qui visite
La méthode `watcher_admin` retournerait la simple notification 'watcher_admin.html.erb' si elle existe et que c'est l'admin.
La méthode `action_user` return le code du formulaire 'action_user.html.erb'
La méthode `watcher_admin` retournerait la notification pour l'user.
Tous ces fichiers se serviraient du fichier `action_watcher_helpers.rb` définissant des méthodes utiles à tous les autres fichiers.

L'ActionWatcher appartient toujours à un user. L'autre personne concernée est l'administrateur, toujours.
</Text>
        </Document>
        <Document ID="09A74A46-A528-4ED0-86B4-74839BC45AF9">
            <Title>Ajouter un message d'erreur</Title>
            <Text>On peut ajouter un message d'erreur particulier à un retour de formulaire en utilisant :


	&lt;instance&gt;.errors.add(:&lt;property&gt;, "&lt;message&gt;")	

	
Par exemple, dans un contrôleur :


	if password.blank?
		@user.errors.add(:password, 'ne doit pas être vide')
	else
		# =&gt; OK
	end

</Text>
        </Document>
        <Document ID="56881565-8CB5-47DA-ADE1-F08A61B3A0CE">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="91C3EFDC-8A8B-48A0-A7A9-682663C2801E">
            <Title>Processus courants</Title>
            <Text>Notamment avec "spring" (serveur de Rails), il peut y avoir multiplication des processus ouverts.
Pour voir les processus (tous) :
 $ ps aux 
Pour voir les processus particuliers (ici consacrés à spring) :
 $ ps aux | grep spring 

Pour "tuer" un processus (-9 fonctionne mieux, semble-t-il) :

 $ kill -9 &lt;numéro de processus&gt;
 $ kill -15 &lt;numéro du processus&gt;           

Ou pour tuer tous les processus d'un certain nom (ne pas oublier le "p" de "pkill") :
 $ pkill -15 -f spring 
</Text>
        </Document>
        <Document ID="996AB775-1C69-4DE6-A705-9A48765509DB">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'une étape de module d'apprentissage absolu sont :

belongs_to :abs_module


numero
Numéro de l'étape (de 1 à 999)
type
(nouvelle propriété) Type de l'étape. Cf. Type.
titre
Titre de l'étape
objectif
L'objectif à atteindre au cours de cette étape
travail
Définition du travail (HTML). Note : peut être une liste de travaux.
methode
Éléments de méthode
travaux
OBSOLÈTE
duree
Nombre de jours par défaut pour cette étape.
duree_max
La durée maximum acceptable pour cette étape.
liens
Liens utiles, par exemple vers la collection Narration
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="D9C57209-91BA-4805-9725-5E9F17730B56">
            <Title>Redirection après run</Title>
            <Text>Pour rediriger l'action après son exécution, on utilise tout simplement la méthode `redirect_to` avec en argument la nouvelle direction.

Mais noter que cette méthode est propre au modèle watcher, ça n'est pas le redirect_to des contrôleurs. Cf. action_watcher.</Text>
        </Document>
        <Document ID="6E25DD15-7A1F-4DE7-A705-F0F7C695126A">
            <Title>Statut</Title>
            <Text>Propriété :statut

0	Simple inscrit
1	Simple icarien
2	Rédacteur (de ?)
4	Administrateur
8	Grand manitou

Donc : 
14 : tous les droits (super administrateur, rédacteur)
6 	: administration et rédaction (4 + 2)</Text>
        </Document>
        <Document ID="4F4727C1-4967-4AE9-98FB-955A4531697C">
            <Title>Paiements</Title>
            <Text>Les paiements concernant un module d'icarien.

</Text>
        </Document>
        <Document ID="69EC93B0-3A0E-4DCC-B50E-9F9F7F9CF49D">
            <Title>Type de la rangée</Title>
            <Text>La notification a un type qui est renvoyé par la méthode `notification_type` qui doit être définie dans l'action_watcher_helpers.rb du watcher.

Ce type permet de définit l'aspect de la notification. Les types possibles sont :

simple-notice
Une note d'information sans importance
action-required
Une action requise, mais pas urgente, comme par exemple une attribution de note à un document lu.
main-action-required
Une action importante requise, comme par exemple le démarrage d'un module d'apprentissage ou un paiement.


			

On le définit dans la méthode notification_type qui est définie par défaut dans l'helper du watcher (./lib/action_watchers/&lt;dossier/watcher&gt;/action_watcher_helpers.rb) :


	def notification_type(cuser)
		if owner?(cuser)
			'&lt;type quand c'est la notification USER&gt;'
		else
			'&lt;type quand c'est la notification ADMIN&gt;'
		end
	end

</Text>
        </Document>
        <Document ID="36F6909E-D617-4006-98D9-7515D7B24D34">
            <Title>Update</Title>
            <Text>Pour actualiser un objet :


	objet.update_attributes({... attributs})
	# =&gt; true/false


La méthode ci-dessous passe par la validation.

On peut en revanche by-passer la validation en utilisant la méthode singulière :


	objet.update_attribute(:attribut, valeur)


On peut aussi utiliser la méthode qui semble ne pas passer par la validation, lorsque plusieurs valeurs sont à modifier en même temps (noter que update_at n'est pas actualisé, avec cette méthode) :


	objet.update_columns(&lt;hash&gt;) 


</Text>
        </Document>
        <Document ID="1A8D135B-0EFE-4E5C-BDF6-CF7EDB4D5F86">
            <Title>Glyphicons</Title>
        </Document>
        <Document ID="FA60E3B3-A4F7-47F5-BE63-FBFF169CDBDB">
            <Title>Générer sans fiche test</Title>
            <Text>Pour générer un contrôleur sans feuille de test, on ajoute l'option --no-test-framework.
Par exemple :


	$ rails g controller Controls edit new --no-test-framework  

</Text>
        </Document>
        <Document ID="F7FB0D91-055F-4B5F-9372-2B29CA06D129">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'un action_watcher :

belongs_to :user


model
Modèle qui sera touché par l'actionwatcher
Avant : `objet`.
model_id
Identifiant de l'instance du modèle.
Avant : `objet_id`
action_watcher_path
Path de l'action watcher, là où se trouve ses fichiers.
Avant : `processus`
triggered_at
Date où le watcher doit être déclenché. Par exemple, pour un paiement, quelques jours avant son échéance.
Avant : `trigerred`
data
Éventuellement les données dont a besoin l'action-watcher. 
TODO : voir comment elles seront évaluées. Ce sera peut-être un json.
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="F07B69FF-3274-4D6A-9617-A4DEA77365AE">
            <Title>LECTURE TUTORIEL</Title>
        </Document>
        <Document ID="F2C13F7D-4190-4EFC-BABF-C0F82C1CE425">
            <Title>Lancer un serveur en production</Title>
            <Text>
	
	rails s -e production

</Text>
        </Document>
        <Document ID="9F311ED5-158F-4B88-B8ED-A48771C7F74A">
            <Title>Production (heroku)</Title>
        </Document>
        <Document ID="0F5A3B5E-6516-4FE8-8ED4-C4ACE27F9EBC">
            <Title>Formulaire</Title>
            <Text>Pour faire un un formulaire devant jouer l'action-watcher, utiliser :


	= form_for(action_watcher.objet, url: action_watcher.form_url, method: :post) do |f|
		...
		.right.vair
			= f.submit('Soumettre le formulaire', class: 'btn btn-primary btn-small')

</Text>
        </Document>
        <Document ID="35D45C28-0FAC-4792-AEF7-BDEAEA2943BF">
            <Title>Propriétés</Title>
            <Text>Les propriétés des lectures d'un document sont :

belongs_to :ic_document
belongs_to :user, as: lecteur
belongs_to :user, through :ic_document, as: auteur

comments
Commentaire éventuel du lecteur
original_cote
Cote sur 5 attribuée par le lecteur au document original
comments_cote
Cote sur 5 du lecteur au document commenté
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="380EB6BA-F860-4D28-B1D5-3AD51CADFF0F">
            <Title>Modèle avec documents</Title>
            <Text>Si un modèle utilise des documents, par exemple la classe IcDocuments sur l'atelier Icare, on utilise soit has_one_attached :&lt;nom&gt; soit has_many_attached :&lt;nom&gt;.

Par exemple, puisque les IcDocuments possèdent une version originale et une version commentées :


	class IcDocument &lt; ApplicationRecord
		has_one_attached :original
		has_one_attached :comments
		...
	end


Ensuite pour attacher un fichier en revenant du formulaire par exemple :

	&lt;model&gt;.&lt;nom attachement&gt;.attach(params[:&lt;nom champ file&gt;])

Par exemple, soit icdocument l'instance IcDocument d'un double document de travail :

	icdocument.original.attach(params[:work][:original_file])

Et plus tard pour rendre les commentaires

	icdocument.comments.attach(params[:work][:comments_file])

Note : penser à ajouter :original_file et :comments_file aux paramètres permis. Par exemple :


	def work_params
		params.require(:work).permit(:original_file)
	end

	def comments_params
		params.require(:work).permit(:comments_file)
	end


Pour attacher un fichier autrement que par un formulaire, on utilise :

		icdocument.original.attach(
			io: 				File.open('path/to/file'), 
			filename: 		'filename.ext', 
			content_type:		 'application/pdf' # ou autre
		)

</Text>
        </Document>
        <Document ID="8E87DB4A-9EC9-4F69-A6F7-CDDD7B578372">
            <Title>Modification du mail envoyé</Title>
            <Text>Le mail envoyé à l'exécution peut être modifié de deux façons. La première consiste à mettre une alternative dans le mail (if… else… end), le second consiste à modifier le nom du mail choisi.
Modification par alternative
Par exemple dans .../mailto_admin_after.html.erb

	&lt;% if cest_ce_cas_la %&gt;
		... contenu du mail ...
	&lt;% else %&gt;
		... contenu alternatif
	&lt;% end %&gt;

Modification du mail utilisé
Par défaut, c'est le mail `mailto_&lt;qui&gt;_after.html.erb` qui est utilisé. On peut modifier ce nom en ajoutant dans le code :
	self.mailto_admin_after_name = 'autre_nom_mail.html.erb'
	self.mailto_user_after_name = 'mail_alternatif_cequonveut.html.erb'

On met ce code par exemple dans la méthode `execute` de l'action-watcher :


	def execute
		... code à exécuter ...
		if cest_pas_le_bon_cas
			self.mailto_admin_after_name = 'refus_action.html.erb'
		end
	end


Bien sûr, le mail `refus_action.html.erb' doit exister dans le dossier de l'action-watcher.</Text>
        </Document>
        <Document ID="3858968C-A691-412B-8199-3D5FBA49FE0C">
            <Title>Flash</Title>
            <Text>flash[:success] = "Le message de succès"

flash[:danger] = "Le message d'échec"

Les quatre types gérés par bootstrap sont :
:success
:info
:warning
:danger

Pour tester qu'il y a un message flash :


	assert flash.empty?
	assert flash.any?
	assert_not flash.empty?

</Text>
        </Document>
        <Document ID="9CA6B40A-65C2-4C36-8B12-EB2AA9DF1B7A">
            <Title>MAILS</Title>
        </Document>
        <Document ID="F1D85AF7-3543-4C42-9A42-C249FF1EC1BC">
            <Title>Détruire le document</Title>
            <Text>Utiliser la méthode `purge'

		icdocument.original.purge
		ou
		icdocument.original.purge_later # avec Active Job

</Text>
        </Document>
        <Document ID="1C315745-E9BA-4191-8F08-48A3439443A8">
            <Title>MAILS</Title>
            <Text>Récupérer le dernier mail en intégration :

	mail = ActionMailer::Base.deliveries.last  

Pour retrouver un texte dans le corps, par exemple une URL :

	url = mail.body.encoded.match(/"[^"]+"&gt;Modifi/)[1] 

</Text>
        </Document>
        <Document ID="BDF6C165-D027-4AD0-A539-F2A4BBD3D815">
            <Title>MAILS</Title>
        </Document>
        <Document ID="205817A2-7E12-4BA5-92B8-3E77A4F51C2B">
            <Title>Introduction</Title>
            <Text>Pendant la phase de conception du watcher, on peut utiliser les méthodes suivantes dans la méthode `execute` du watcher pour ne pas tout recommencer à chaque fois :

	dont_destroy			Empêche la destruction du watcher
	dont_send_mails		Ne procède pas à l'envoi des mails</Text>
        </Document>
        <Document ID="2A7D54BE-CAC8-44CE-A563-2726572156F8">
            <Title>ActionWatchers</Title>
        </Document>
        <Document ID="96F6FF97-6E89-4C6A-89F0-84B8C91A3F7D">
            <Title>Object.create / .save</Title>
            <Text>La méthode ActiveRecord#create retourne l'objet créé (on peut donc obtenir tout de suite son ID) tandis que ActiveRecord#save retourne true (si OK) ou false (si pas OK).</Text>
        </Document>
        <Document ID="7A1089CE-9B6C-4224-A256-2A6BFADA70D2">
            <Title>De l'action-watcher lui-même</Title>
        </Document>
        <Document ID="7451CE5B-A7AB-4FBE-853D-773E6C9C48A2">
            <Title>Introduction</Title>
            <Text>Ce manuel présente l'utilisation du site de l'atelier Icare en version Ruby On Rails mise en place en 2019.</Text>
        </Document>
        <Document ID="32863252-9761-489B-8798-6F39756A8C19">
            <Title>Aide</Title>
            <Text>Les fichiers d'aide doivent se définir dans le dossier :


	./app/views/aide/files


On les invoque par :


	aide_{url|path}('&lt;affixe fichier&gt;')


Par exemple :


	= link_to 'Le partage', aide_url('partage')


Ce lien affiche le contenu du fichier `./app/views/aide/files/partage.html.md`</Text>
        </Document>
        <Document ID="BBE7194B-8ACC-47A6-92E5-3150D9C65344">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'une étape de module d'apprentissage d'icarien sont :

belongs_to :ic_module
belongs_to :abs_etape
belongs_to :user, through :ic_module
has_many :documents


status
Statut de l'étape. Cf. Statuts
options
Options de l'étape, quelques valeurs utiles, fixes ou mobiles. Cf. Options
travail_propre
Éventuellement, le travail propre de l'étape, ou un travail supplémentaire pour l'étape.
started_at
Date de démarrage de l'étape. Elle pourrait être définie lorsque l'user arrive sur son bureau et que son travail est affiché.
expected_end_at
Date de fin attentue pour le travail.
ended_at
Date effective de fin de l'étape (remise des documents)
Avant : ending_at
expected_comments_at
La date espérée de remise des commentaires de l'étape. Note : ce n'est pas/plus les documents qui portent cette donnée.
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="AC4F88F7-4E13-4695-82E6-D2622D0F2CE7">
            <Title>Ajouts à test_helper.rb</Title>
            <Text>Voir dans le fichier test_helper.rb les ajouts faits pour améliorer les tests.</Text>
        </Document>
        <Document ID="75F2F529-5F9F-4214-9241-CA5E2D2529F9">
            <Title>Zip et download</Title>
            <Text>Pour voir un exemple complet de zippage avec download (ou inversement), consulter le code du fichier action_watcher.</Text>
        </Document>
        <Document ID="CB60A87B-5AC0-487F-A0AB-8D44672FD41F">
            <Title>Tickets</Title>
            <Text>Description rapide de l'utilisation d'un ticket :

Création du ticket, par exemple pour un ticket qui s'appelle 'jouer_le_ticket' (le nom est purement indicatif) :


	ticket = Ticket.new(name: 'jouer-ticket', action: '/user/1', duree: 4)
	# Ce ticket aura une durée de vie de 4 jours et rejoindra l'adresse /user/1
	# quand il sera invoqué
	@ticket = Phil.tickets.create(ticket.hash_to_create)
	# Noter que `@ticket` est une instance distincte de `ticket`


Dans le mail (vue) qui contient le lien pour jouer le ticket, on met :


	= @ticket.link('Jouer le ticket')

	ou
	= link_to 'Jouer le ticket', @ticket.url
	ou
	= link_to 'Jouer le ticket', ticket_run_url(ticket.id, token: ticket.token)


Lorsqu'on joue le ticket (i.e. lorsqu'on clique sur le lien), la méthode TicketController#run est appelée. Si un paramètre uid a été ajouté à l'url du ticket (c'est le cas lorsqu'on utilise ticket#link pour créer le lien), la méthode commence par vérifier qu'il s'agit bien de l'user possesseur du ticket ou d'un administrateur. Dans le cas contraire, une exception est levée.

Ensuite, dans la méthode appelée (celle définie par `action`, if any), on peut faire un nouveau contrôle pour savoir si c'est le bon user, en utilisant ce code :


Détail des procédures

Pour créer un ticket à quelqu'un :

	ticket = Ticket.new(
		name: '&lt;nom générique&gt;', 
		action: '&lt;code à exécuter&gt;|&lt;route&gt;',
		[duree: &lt;durée de vie du ticket&gt;]
	)
	&lt;user&gt;.tickets.create(ticket.hash_to_create)

Par exemple :


	ticket = Ticket.new(name: 'activation_compte', action: "User.find(#{benoit.id}).confirm_compte", duree: 2.days)
	# Crée un objet qui possède les propriétés :
	#	:name, :digest, :action, :token, :expire_at
	autre_ticket = benoit.tickets.create(ticket.hash_to_create)


Noter qu'on peut aussi envoyer seulement l'instance :


	benoit.tickets.create(ticket)


ATTENTION, si on veut récupérer le token du ticket, il ne faut pas faire `user.tickets.last` (qui créerait une nouvelle instance avec un token vide), il faut la prendre du ticket ou autre_ticket.

L':action peut être soit du code Ruby à évaluer, soit une route.

Quand il s'agit d'une route, il est toujours ajoutée à cette route le paramètre :uid qui contient l'ID de l'user possédant le ticket. Le ticket, lui est détruit, donc on ne peut pas le retrouver (mais à l'avenir, s'il s'avère qu'il est intéressant de le reprendre, on pourra le garder et le détruire après).

On peut passer des variables dans l'action ou la route, avec :

	 %{&lt;nom variable ci-dessous&gt;} 

Les noms de variable possible sont :

	%{digest}  		# pour une url/action par exemple
	%{token}  		# pour une url/action par exemple
	%{user_id}		# ID du possesseur du ticket

Par exemple :

	action: '/icmodule/%{digest}/edit'

Note : je ne sais plus à quoi peut servir la suite ci-dessous.

Avant l'exécution du code (en fait, dans la méthode), on met le digest du ticket dans la variable session :ticket_digest


	session['ticket_digest'] = &lt;ledigestduticket&gt;


Donc on peut l'obtenir par : 


	tdigest = session['ticket_digest']


De cette manière, on peut faire encore des contrôles, comme lorsque l'url appelée en action contient le même token que le ticket, pour double vérification.
Ensuite, il suffit donc de faire :

	if BCrypt::Password.new(session['ticket_digest']).is_password?(params[:id])
		# =&gt; OK
	else
		# =&gt; Not OK
	end</Text>
        </Document>
        <Document ID="C5C9C828-8A59-46AD-8E55-4344F29C46BD">
            <Title>Propriétés</Title>
            <Text>Les propriétés d'un module d'apprentissage d'icarien sont :

belongs_to :user
belongs_to :abs_module
has_many :paiements
has_many :pauses
has_many :ic_etapes

has_many :documents, through: :ic_etapes


project_name
Nom du projet (son titre) s'il en a un
state
Etat du module (nouvelle propriété). Cf. State
options
OBSOLÈTE (cf. le fichier Options)
started_at
Date de démarrage du module
Avant : starting_at
ended_at

Date de fin du module (réelle, pas une pause)
Avant : ending_at
next_paiement
La date de prochain paiement (if any)
	+ les timestamps par défaut, created_at et updated_at
					</Text>
        </Document>
        <Document ID="01F41402-4522-41EA-8C60-C12EEBCDA45B">
            <Title>Gérer les processus en cours</Title>
            <Text>(utile par exemple lorsque le message d'erreur est "Can not run more than 1 Free size dyno.")


	$ heroku ps
	# =&gt; Liste des processus

	$ heroku ps:stop &lt;dyno&gt;
	# =&gt; Stop un processus en cours


Par exemple :
	=== web (Free): bundle exec puma -C config/puma.rb (1)
	web.1: starting 2018/09/27 08:24:02 +0300 (~ 12s ago)

C'est "web.1" le nom du dyno. Donc la ligne suivante l'arrête :

	$ heroku ps:stop web.1

</Text>
        </Document>
        <Document ID="231FCC1C-1690-4854-AF63-EBBB69D7B48F">
            <Title>Définition générale avant test</Title>
            <Text>def set_up
	@variable = "valeur"
	@autre_variable = "autre valeur"
end</Text>
        </Document>
        <Document ID="03AF605A-E96A-432B-B9F7-C7AAAFC5DEB1">
            <Title>Redictions particulières</Title>
            <Text>Pour retourner à la page précédente, on peut utiliser :


	redirect_back(fallback_location: root_path)


</Text>
        </Document>
        <Document ID="8A7ECB95-D272-4713-957D-BB4CBE6F15FA">
            <Title>Introduction</Title>
            <Text>Ce document contient ce que j'ai appris au cours de la (re)lecture du tutoriel de Mickael Hartl.</Text>
        </Document>
        <Document ID="793D767B-EB19-44E0-A946-EBFBD50D1354">
            <Title>Bootstrap</Title>
            <Text>Variables bootstrap :

https://github.com/twbs/bootstrap-rubygem/blob/master/assets/stylesheets/bootstrap/_variables.scss

Breakpoints :

	lg		large - Grand ordinateur (&gt; 1200)
	md	medium - Petit portable (&gt; 992px)
	sm	small - tablette (&gt; 768px)
	xs		mini - Smartphone (&lt; 768px)</Text>
        </Document>
    </Documents>
</SearchIndexes>