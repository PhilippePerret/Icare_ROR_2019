{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf0 On utilise la class BCrypt\
\
Soit un mot \'e0 coder 'mot en clair'.\
\
	version_claire = 'mot en clair'\
\
	# Pour une utilisation avec un \'ab\'a0token\'a0\'bb, on utilise :\
	# C'est ce token qui sera utilis\'e9 et compar\'e9 \'e0 la version\
	# enregistr\'e9e et crypt\'e9e\
	version_claire = 
\b SessionsHelper.new_token
\b0 \
\
On peut en obtenir une version crypt\'e9e avec :\
\
	version_crypted = BCrypt::Password.create(version_claire[, cost: <prix>])\
	# <prix> est un nombre qui augmente le nombre de passe.\
\
On enregistre ce mot crypt\'e9 dans une table :\
\
	model.update_attribute(cversion: version_crypted.to_s)\
	# Remarquer le "to_s"\
\
Pour tester la correspondance :\
\
	c = BCrypt::Password.new(model.cversion)\
	# cversion est la version crypt\'e9\'e9 et stringifi\'e9e du mot de passe\
	if c == 'mot en clair' => true\
		# Noter que BCrypt::Password surclasse la m\'e9thode '=='\
		# C'est OK\
	else\
		# Le mot cod\'e9 ne correspond pas\
	end}