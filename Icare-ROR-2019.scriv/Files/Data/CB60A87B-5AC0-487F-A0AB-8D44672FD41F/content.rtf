{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fmodern\fcharset0 CourierNewPSMT;
}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red26\green26\blue26;\red251\green0\blue23;
}
{\*\expandedcolortbl;;\csgray\c100000;\csgray\c13700;\csgenericrgb\c98600\c0\c9100;
}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf0 Pour cr\'e9er un ticket \'e0 quelqu'un :\
\
	ticket = Ticket.new(\
		name: '<nom g\'e9n\'e9rique>', \
		action: '<code \'e0 ex\'e9cuter>|<route>',\
		[duree: <dur\'e9e de vie du ticket>]\
	)\
	<user>.tickets.create(ticket.hash_to_create)\
\
Par exemple :\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 \up4 <$Scr_Cs::0>
\f2\fs22 \
	ticket = Ticket.new(name: 'activation_compte', action: "User.find(#\{benoit.id\}).confirm_compte", duree: 2.days)\
	# Cr\'e9e un objet qui poss\'e8de les propri\'e9t\'e9s :\
	#	:name, :digest, :action, :token, :expire_at\
	autre_ticket = benoit.tickets.create(ticket.hash_to_create)\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf4 \cb1 \up0 <!$Scr_Cs::0>
\f0\b\fs28 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx10080\sl264\slmult1\pardirnatural\partightenfactor0

\b0 \cf0 \strike \strikec0 Noter qu'on peut aussi envoyer seulement l'instance :\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx10080\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 \up4 \strikec2 <$Scr_Cs::0>
\f2\fs22 \
	benoit.tickets.create(ticket)\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx10080\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \cb1 \up0 \strike0\striked0 <!$Scr_Cs::0>
\f0\fs28 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\sl264\slmult1\pardirnatural\partightenfactor0

\b \cf4 ATTENTION
\b0 \cf0 , si on veut r\'e9cup\'e9rer le token du ticket, il ne faut pas faire `user.tickets.last` (qui cr\'e9erait une nouvelle instance avec un token vide), il faut la prendre du ticket ou autre_ticket.\
\
L'
\f1\fs24 \cf2 \cb3 \up4 <$Scr_Cs::0>
\f2\fs22 :action
\f1\fs24 \cf0 \cb1 \up0 <!$Scr_Cs::0>
\f0\fs28  peut \'eatre soit du code Ruby \'e0 \'e9valuer, soit une route.\
\
Quand il s'agit d'une route, il est toujours ajout\'e9e \'e0 cette route le param\'e8tre 
\f1\fs24 \cf2 \cb3 \up4 <$Scr_Cs::0>
\f2\fs22 :uid
\f1\fs24 \cf0 \cb1 \up0 <!$Scr_Cs::0>
\f0\fs28  qui contient l'ID de l'user poss\'e9dant le ticket. Le ticket, lui est d\'e9truit, donc on ne peut pas le retrouver (mais \'e0 l'avenir, s'il s'av\'e8re qu'il est int\'e9ressant de le reprendre, on pourra le garder et le d\'e9truire apr\'e8s).\
\
On peut passer des variables dans l'action ou la route, avec :\
\
	
\f1\fs24 \cf2 \cb3 \up4 <$Scr_Cs::0>
\f2\fs22  %\{<nom variable>\} 
\f1\fs24 \cf0 \cb1 \up0 <!$Scr_Cs::0>
\f0\fs28 \
\
Les noms de variable possible sont :\
\
	%\{digest\}  		# pour une url/action par exemple\
	%\{token\}  		# pour une url/action par exemple\
	%\{user_id\}		# ID du possesseur du ticket\
\
Par exemple\'a0:\
\
	action: '/icmodule/%\{digest\}/edit'\
\
Avant l'ex\'e9cution du code (en fait, dans la m\'e9thode), on met le digest du ticket dans la variable session :ticket_digest\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 \up4 <$Scr_Cs::0>
\f2\fs22 \
	tdigest = session['ticket_digest']\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \cb1 \up0 <!$Scr_Cs::0>
\f0\fs28 \
De cette mani\'e8re, on peut faire encore des contr\'f4les, comme lorsque l'url appel\'e9e en action contient le m\'eame token que le ticket, pour double v\'e9rification.\
Ensuite, il suffit donc de faire :\
\
	if BCrypt::Password.new(session['ticket_digest']).is_password?(params[:id])\
		# => OK\
	else\
		# => Not OK\
	end}